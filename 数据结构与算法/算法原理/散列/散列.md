# 散列

## 概念

散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是不支持需要元素排序信息的操作。

理想的散列表数据结构是一个包含关键字的固定大小的数组。每个关键字被映射到从0到TableSize-1这个范围中的某个数，并且被放到适当的单元中。

这个映射叫做散列函数，该函数要在单元之间均匀地分配关键字，理想情况下它应该运算简单并且应该保证任何两个不同的关键字映射到不同的单元。

简单的散列函数：
- 关键字为整数：返回Key mod TableSize
- 关键字为字符串：把字符串中字符的ASCII码值加起来当成Index，返回Index mod TableSize

装填因子$\lambda$：散列表中的元素个数与散列表大小的比值。

冲突：两个关键字散列到同一个值

解决冲突的方法：
- 分离链接法
- 开放定址法
- 再散列法

## 分离链接法

将散列到同一个值的所有元素保留到一个表中。

分离链接法的一般法则是使得表的大小尽量与预料的元素个数差不多（即让$\lambda$约等于1）。

分离链接法实现：
- [hashSep.h](hashSep.h)
- [hashSep.c](hashSep.c)

## 开放定址法

如果有冲突发生，那么就要尝试选择另外的单元，直到找出空的单元为止。单元$h_i(X)=(Hash(X) + F(i)) mod TableSize且F(0)=0$。

开放定址法的装填因子应该低于0.5。

线性探测法：
- 函数F是i的线性函数，典型场景为$F(i)=i$。
- 缺点：占据的单元会形成区块，称为一次聚集。散列到该区块中的任何关键字都需要多次试选单元才能够解决冲突。

平方探测法：
- 冲突函数F是i的二次函数，典型场景为$F(i)=i^2$。
- 缺点1：
  - 一旦表被填满超过一半，当表的大小不是素数时甚至在表被填满一半之前，就不能保证一次找到一个空单元了。
  - 标准的删除操作不能执行，因为相应的单元可能已经引起过冲突，元素绕过它存在了别处。

双散列：
- 选择第二个冲突函数。
- 一个流行的选择是$F(i)=i*hash_2(X)$，将第二个散列函数应用到X并在距离$hash_2(X)，2hash_2(X)$等处探测。

开放定址法实现：
- [hashSep.h](hashSep.h)
- [hashSep.c](hashSep.c)

## 再散列法

再散列：建立另一个大约两倍大的表（而且使用一个相关的新的散列函数），扫描整个原始散列表，计算每个（未删除）的元素的新散列值并将其插入到新表中。

做法：
- 只要表满到一半就再散列
- 只有当插入失败时才再散列
- 途中策略：当表到达某一个装填因子时进行再散列
