# 函数

## 函数基础

一个典型的函数定义包括以下部分：
- 返回类型
- 函数名字
- 由 0 个或多个形参组成的列表：形参以逗号隔开，形参的列表位于一对圆括号之内
- 函数体

通过调用运算符来执行函数：
- 调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针
- 圆括号之内是一个用逗号隔开的实参列表，用实参初始化形参
- 调用表达式的类型就是函数的返回类型

函数的调用完成两项工作：
- 用实参初始化对应的形参
- 将控制权转移给被调函数
- 主调函数的执行被暂时中断，被调函数开始执行

执行函数的第一步是隐式地定义并初始化它的形参

当遇到一条 return 语句时函数结束执行过程

return 语句完成两项工作：
- 返回 return 语句中的值
- 将控制权从被调函数转移回主调函数

实参是形参的初始值：
- 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值

实参的类型必须与相对应的形参类型匹配

函数的形参列表：
- 函数的形参列表可以为空，但是不能省略
- 形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明
- 任意两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字
- 形参名是可选的，但是无法使用未命名的形参
- 即使某个形参不被使用，也必须为它提供一个实参

函数返回类型：
- 一种特殊的返回类型是 void，它表达函数不返回任何值
- 函数的返回类型不能是数组类型或者函数类型，但是可以是指向数组或函数的指针

### 局部对象

名字有作用域，对象有生命周期
- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的生命周期是程序执行过程中该对象存在的一段时间

函数体是一个语句块，块构成一个新的作用域
- 形参和函数体内部的变量统称为局部变量，他们对函数而言是局部的，仅在函数的作用域内可见
- 局部变量还会隐藏在外层作用域中同名的其他所有声明

在所有函数体之外定义的对象存在于程序的整个执行过程中，此类对象在程序启动过程时被创建，直到程序结束才会被销毁

自动对象：
- 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义的语句时创建该对象，当到达定义所在块末尾时销毁它
- 只存在于块执行期间的对象称为自动对象，当块的执行结束后，块中创建的自动对象的值就变成未定义的了
- 形参是一种自动变量

对于局部变量对应的自动对象：
- 如果变量定义本身含有初始值，就用这个初始值进行初始化
- 如果变量定义本身不含初始值，执行默认初始化

局部静态对象：
- 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即时对象所在的函数结束执行也不会对他有影响
- 如果局部静态变量没有显示的初始值，他将执行值初始化

### 函数声明

函数的名字必须在使用之前被声明

函数指定定义一次，但可以声明多次

函数声明无需函数体，用一个分号替代即可

因为函数的声明不包含函数体，所以也就无需形参的名字

函数声明也称作函数原型

函数应该在头文件中声明，而在源文件中定义

## 参数传递

每次调用函数时都会重新创建它的形参，并用传入的实参进行初始化

如果形参是引用类型，它将绑定到对于的实参上，否则，将实参的值拷贝后赋值给形参
- 当形参是引用类型时，称对应的实参被引用传递或者函数被传引用调用
- 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，称形参被值传递或者函数被传值调用

### 传值参数

当初始化一个非引用类型的变量时初始值被拷贝给变量，此时对变量的改动不会影响初始值，传值参数的机理完全一样，函数对形参做的所有操作都不会影响实参

当执行指针拷贝时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针

因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值

### 传引用参数

对于引用的操作实际上作用在引用所引的对象上，通过使用引用形参，允许函数改变一个或多个实参的值

引用形参绑定初始化它的对象

拷贝大的类类型对象或者容器对象比较低效，甚至有的类型根本不支持拷贝操作，当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象

如果函数无需改变引用传参的值，最好将其声明为常量引用

一个函数只能返回一个值，然而有时候需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径

### const 形参和实参

当用实参初始化形参时会忽略掉顶层 const，当形参有顶层 const 时，传给他常量对象或非常量对象都是可以的

指针或引用形参与 const：
- 可以用非常量初始化一个底层 const 对象，但是反过来不行
- 一个普通的引用必须使用同类型的对象初始化

尽量使用常量引用

把函数不会改变的形参定义成普通的引用是一种比较常见的错误
- 这会给函数的调用者一种误导，即函数可以修改它的实参的值
- 使用引用而非常量引用会极大地限制函数所能接收的实参类型：不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用参数

### 数组形参

数组的两个特殊性质：
- 不允许拷贝数组
- 使用数组时通常会将其转换成指针

因为不能拷贝数组，所以无法以值传递的方式使用数组形参

因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针

尽管不能以值传递的方式传递数组，但是可以把形参写成类似数组的形式

以数组为形参的函数必须确保使用数组时不会越界：
- 使用标记指定数组长度：要求数组本身包含一个结束标记，如 C 分个字符串
- 使用标准库规范：传递指向数组首元素和尾后元素地指针
- 显式传递一个表示数组大小的形参

当函数不需要对数组元素执行写操作时，数组形参应该是指向 const 的指针，只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针

形参可以是数组的引用，此时引用绑定到对应的实参上，也就是绑定到数组上

当将多维数组传递给函数时，真正传递的是指向数组首元素的指针：一个指向数组的指针

### 含有可变形参的函数

编写能处理不同数量实参的函数的方法：
- 如果所有的实参类型相同，可以传递一个名为 initializer_list 的标准库类型
- 如果实参类型不同，可以使用可变参数模板
- 用于与 c 函数交互时，可以使用省略符传递可变数量的实参

initializer_list 对象中的元素永远是常量值，无法改变 initializer_list 对象中元素的值

如果想向 initializer_list 形参中传递一个值的序列，必须把序列放在一对花括号内

含有 initializer_list 形参的函数也可以同时拥有其他形参


















