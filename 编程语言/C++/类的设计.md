# 类的设计

拷贝控制操作：
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

## 拷贝构造函数

拷贝构造函数第一个参数是自身类类型的引用，且任何额外参数都有默认值

拷贝构造函数的第一个参数必须是一个引用类型：
- 拷贝构造函数被用来初始化非引用类类型参数
- 如果其参数不是引用类型，则调用永远不会成功：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环

编译器合成的拷贝构造函数：
- 将每个非 static 成员逐个拷贝到正在创建的对象中
- 对于类类型成员，使用其拷贝构造函数来拷贝
- 内置类型成员直接拷贝
- 数组逐元素地拷贝每一个成员，如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝

拷贝构造函数会在以下几种情况被隐式使用，因此不应该是 explicit 的：
- 使用 = 定义对象
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些类类型会对它们所分配的对象使用拷贝初始化

直接初始化和拷贝初始化：
- 直接初始化使用普通的函数匹配来选择参数最匹配的构造函数
- 拷贝初始化将右侧运算对象拷贝到正在创建的对象中，如果需要的话还会进行类型转换
- 在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象，但此时拷贝/移动构造函数必须存在并且可访问
```C++
string null_book = "9-999-99999-9"; //拷贝初始化
string null_book("9-999-99999-9"); //直接初始化
```

## 拷贝赋值运算符

赋值运算符通常应该返回一个指向其左侧运算对象的引用

合成的拷贝赋值运算符：
- 将右侧对象的每个非 static 成员赋予左侧运算对象的对应成员
- 通过成员的拷贝赋值运算符完成
- 返回一个指向其左侧运算对象的引用

赋值运算符组合了析构函数和构造函数的操作：
- 类似析构函数，赋值操作会销毁左则运算对象的资源
- 类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据

赋值运算符要点：
- 必须正确处理自赋值
- 应该是异常安全的：当异常发生时能将左侧运算对象置于一个有意义的状态
- 销毁左侧运算对象之前拷贝右侧运算对象
```C++
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    if (this == rhs) { //检测自赋值
        return this;
    }
    auto newp = new string(*rhs.ps); 
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```

## 析构函数

析构函数释放对象使用的资源，并销毁对象的非 static 数据成员

析构函数是类的一个成员函数，名字由 ~ 接类名构成，它没有返回值，也不接受参数
```C++
class Foo {
public:
    ~Foo(); //析构函数
};
```

由于析构函数不接受参数，因此不能被重载

析构函数的工作：
- 析构函数有一个函数体和一个析构部分
- 在一个析构函数中，首先执行函数体，然后销毁对象，成员按初始化顺序的逆序销毁
- 析构部分是隐式的，成员销毁时发生什么完全依赖于成员的类型：
    + 销毁类类型的成员需要执行成员自己的析构函数
    + 内置类型没有析构函数，因此销毁内置类型成员什么也不需要做
- 在设计时，析构函数应当释放对象在生存周期分配的所有资源

析构函数调用的时机：
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

合成的析构函数：
- 合成的析构函数的函数体为空

析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

三/五法则：
- 如果类需要一个析构函数，几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符
- 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然

complex类
```C++
#ifndef __COMPLEX__
#define __COMPLEX__

class complex 
{
public:
    complex(double r = 0, double i = 0)
    : re(r), im(i)
    {   }

    double real() const { return re; }
    double imag() const { return im; }

    complex& operator += (const complex& r);
    complex& operator -= (const complex& r);
    complex& operator *= (const complex& r);
    complex& operator /= (const complex& r);

private:
    double re;
    double im;

    friend complex& __doapl(complex* ths, const complex& r);
    friend complex& __doami(complex* ths, const complex& r);
    friend complex& __doaml(complex* ths, const complex& r);
};

complex& __doapl(complex* ths, const complex& r)
{
    ths->re += r.re;
    ths->im += r.im; 
    return *ths;
}

complex& complex::operator += (const complex& r)
{
    return __doapl(this, r);
}

complex& __doami(complex* ths, const complex& r)
{
    ths->re -= r.re;
    ths->im -= r.im;
    return *ths;
}

complex& complex::operator -= (const complex& r)
{
    return  __doami(this, r);
}

complex& __doaml(complex* ths, const complex& r)
{
    double f = ths->re * r.re - ths->im * r.im;
    ths->im = ths->re * r.im + ths->im * r.re;
    ths->re = f;
    return *ths;
}

complex& complex::operator *= (const complex& r)
{
    return __doami(this, r);
}

inline double real(const complex& r)
{
    return r.real();
}

inline double imag(const complex& r)
{
    return r.imag();
}

inline complex operator + (const complex& x, const complex& y)
{
    return complex(real(x) + real(y), imag(x) + imag(y));
}

inline complex operator + (double x, const complex& y)
{
    return complex(x + real(y), imag(y));
}

inline complex operator + (const complex& x, double y)
{
    return complex(real(x) + y, imag(x));
}

inline complex operator - (const complex& x, const complex& y)
{
    return complex(real(x) - real(y), imag(x) - imag(y));
}

inline complex operator - (const complex& x, double y)
{
    return complex(real(x) - y, imag(x));
}

inline complex operator - (double x, const complex& y)
{
    return complex(x - real(y), imag(y));
}

inline complex operator * (const complex& x, const complex& y)
{
    return complex(real(x) * real(y) - imag(x) * imag(y), real(x) * imag(y) + imag(x) * real(y));
}

inline complex operator * (const complex& x, double y)
{
    return complex(real(x) * y, imag(x));
}

inline complex operator * (double x, const complex& y)
{
    return complex(x * real(y), imag(y));
}

inline complex operator / (const complex& x, double y)
{
    return complex(real(x) / y, imag(x) / y);
}

inline complex operator + (const complex& r)
{
    return r;
}

inline complex operator - (const complex& r)
{
    return complex(-real(r), -imag(r));
}

inline bool operator == (const complex& x, const complex& y)
{
    return (real(x) == real(y) && imag(x) == imag(y));
}

inline bool operator == (const complex& x, double y)
{
    return (real(x) == y && imag(x) == 0);
}

inline bool operator == (double x, const complex& y)
{
    return (x == real(y) && imag(y) == 0);
}

inline bool operator != (const complex& x, const complex& y)
{
    return (real(x) != real(y) || imag(x) != imag(y));
}

inline bool operator != (const complex& x, double y)
{
    return (real(x) != y || imag(x) != 0);
}

inline bool operator != (double x, const complex& y)
{
    return (x != real(y) || imag(y) != 0);
}

#include <cmath>

inline complex polar (double r, double t)
{
  return complex (r * cos (t), r * sin (t));
}

inline complex conj (const complex& x) 
{
  return complex (real (x), -imag (x));
}

inline double norm (const complex& x)
{
  return real (x) * real (x) + imag (x) * imag (x);
}

#include <iostream>
using namespace std;

inline ostream& operator << (ostream& os, const complex& r)
{
    return os << real(r) << " + j" << imag(r); 
}

#endif
```

class with pointer members 必须有 copy ctor 和 copy op=

拷贝构造函数

浅拷贝与深拷贝

拷贝赋值函数
- 检测自我赋值



string类
```C++

```

Object Based（基于对象）：面对的是单一class的设计
Object Oriented（面向对象）：面对的是多重classes的设计，classes和classes之间的关系

Classes的两个经典分类：
- Class without pointer members
- Class with pointer members


行为像值的类：提供类似值的行为，对于类管理的资源，每个对象都拥有一份自己的拷贝
- 有自己的状态
- 当拷贝一个对象时，副本和原对象是完全独立的，改变副本不会对原对象有任何影响

定义行为像值的类需要：
- 定义一个拷贝构造函数，完成类的实际资源的拷贝，而不是拷贝指针
- 定义一个析构函数来释放资源
- 定义一个拷贝赋值运算符来释放当前的资源，并从右侧运算对象拷贝资源

行为像指针的类：
- 共享状态
- 拷贝一个对象时，副本和原对象使用相同的底层数据，改变副本也会改变原对象

定义行为像指针的类需要：
- 定义一个拷贝构造函数和拷贝赋值运算，拷贝指针，而不是完成类的实际资源的拷贝
- 定义一个析构函数来释放资源

方法：
- 使用 shared_ptr
- 使用引用计数

引用计数：
- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定的对象的状态又被一个新用户共享
- 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
- 拷贝赋值运算符递增右则运算对象的计数器，递减左侧对象的计数器，如果左侧对象的计数器变为0，拷贝赋值运算符必须销毁状态

计数器保存在动态内存中，当创建一个对象时，分配一个新的计数器，当拷贝或赋值对象时，拷贝指向计数器的指针
```C++
```

## 交换操作

除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数

如果一个类定义了自己的 swap，那么算法将使用类的自定义版本，否则算法将使用标准库定义的 swap

我们更希望 swap 交换指针，而不是拷贝对象

可以在我们的类上定义一个自己版本的 swap 来重载 swap 的默认行为

swap 函数应该调用 swap 而不是 std::swap：
- 如果存在类型特定的 swap 版本，其匹配程度会优于 std 中定义的版本 （由于模板特化）
- 如果不存在类型特定的版本，则会使用 std 中的版本

定义 swap 的类通常用 swap 来定义他们的赋值运算符：拷贝并交换技术

使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值

