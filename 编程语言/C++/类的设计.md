
complex类
```C++
#ifndef __COMPLEX__
#define __COMPLEX__

class complex 
{
public:
    complex(double r = 0, double i = 0)
    : re(r), im(i)
    {   }

    double real() const { return re; }
    double imag() const { return im; }

    complex& operator += (const complex& r);
    complex& operator -= (const complex& r);
    complex& operator *= (const complex& r);
    complex& operator /= (const complex& r);

private:
    double re;
    double im;

    friend complex& __doapl(complex* ths, const complex& r);
    friend complex& __doami(complex* ths, const complex& r);
    friend complex& __doaml(complex* ths, const complex& r);
};

complex& __doapl(complex* ths, const complex& r)
{
    ths->re += r.re;
    ths->im += r.im; 
    return *ths;
}

complex& complex::operator += (const complex& r)
{
    return __doapl(this, r);
}

complex& __doami(complex* ths, const complex& r)
{
    ths->re -= r.re;
    ths->im -= r.im;
    return *ths;
}

complex& complex::operator -= (const complex& r)
{
    return  __doami(this, r);
}

complex& __doaml(complex* ths, const complex& r)
{
    double f = ths->re * r.re - ths->im * r.im;
    ths->im = ths->re * r.im + ths->im * r.re;
    ths->re = f;
    return *ths;
}

complex& complex::operator *= (const complex& r)
{
    return __doami(this, r);
}

inline double real(const complex& r)
{
    return r.real();
}

inline double imag(const complex& r)
{
    return r.imag();
}

inline complex operator + (const complex& x, const complex& y)
{
    return complex(real(x) + real(y), imag(x) + imag(y));
}

inline complex operator + (double x, const complex& y)
{
    return complex(x + real(y), imag(y));
}

inline complex operator + (const complex& x, double y)
{
    return complex(real(x) + y, imag(x));
}

inline complex operator - (const complex& x, const complex& y)
{
    return complex(real(x) - real(y), imag(x) - imag(y));
}

inline complex operator - (const complex& x, double y)
{
    return complex(real(x) - y, imag(x));
}

inline complex operator - (double x, const complex& y)
{
    return complex(x - real(y), imag(y));
}

inline complex operator * (const complex& x, const complex& y)
{
    return complex(real(x) * real(y) - imag(x) * imag(y), real(x) * imag(y) + imag(x) * real(y));
}

inline complex operator * (const complex& x, double y)
{
    return complex(real(x) * y, imag(x));
}

inline complex operator * (double x, const complex& y)
{
    return complex(x * real(y), imag(y));
}

inline complex operator / (const complex& x, double y)
{
    return complex(real(x) / y, imag(x) / y);
}

inline complex operator + (const complex& r)
{
    return r;
}

inline complex operator - (const complex& r)
{
    return complex(-real(r), -imag(r));
}

inline bool operator == (const complex& x, const complex& y)
{
    return (real(x) == real(y) && imag(x) == imag(y));
}

inline bool operator == (const complex& x, double y)
{
    return (real(x) == y && imag(x) == 0);
}

inline bool operator == (double x, const complex& y)
{
    return (x == real(y) && imag(y) == 0);
}

inline bool operator != (const complex& x, const complex& y)
{
    return (real(x) != real(y) || imag(x) != imag(y));
}

inline bool operator != (const complex& x, double y)
{
    return (real(x) != y || imag(x) != 0);
}

inline bool operator != (double x, const complex& y)
{
    return (x != real(y) || imag(y) != 0);
}

#include <cmath>

inline complex polar (double r, double t)
{
  return complex (r * cos (t), r * sin (t));
}

inline complex conj (const complex& x) 
{
  return complex (real (x), -imag (x));
}

inline double norm (const complex& x)
{
  return real (x) * real (x) + imag (x) * imag (x);
}

#include <iostream>
using namespace std;

inline ostream& operator << (ostream& os, const complex& r)
{
    return os << real(r) << " + j" << imag(r); 
}

#endif
```

Big Three 三个特殊函数
- 拷贝构造函数
- 拷贝赋值函数
- 析构函数

class with pointer members 必须有 copy ctor 和 copy op=

拷贝构造函数

浅拷贝与深拷贝

拷贝赋值函数
- 检测自我赋值



string类
```

```

构造函数：
- 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行
- 构造函数的名称与类的名称相同，并且没有返回值

析构函数：
- 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行
- 析构函数的名称与类的名称相同，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数
- 析构函数有助于在跳出程序前释放资源

拷贝构造函数调用时机：
- 用已经创建好的对象初始化新的对象
- 以值传递的方式对函数参数进行传值
- 以值方式返回局部对象


Object Based（基于对象）：面对的是单一class的设计
Object Oriented（面向对象）：面对的是多重classes的设计，classes和classes之间的关系

Classes的两个经典分类：
- Class without pointer members
- Class with pointer members

头文件中的防卫式声明
```C++
#ifndef __COMPLEX__
#define __COMPLEX__

#endif
```