# 类的设计

拷贝控制操作：
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

## 拷贝构造函数

拷贝构造函数第一个参数是自身类类型的引用，且任何额外参数都有默认值

拷贝构造函数的第一个参数必须是一个引用类型：
- 拷贝构造函数被用来初始化非引用类类型参数
- 如果其参数不是引用类型，则调用永远不会成功：为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环

编译器合成的拷贝构造函数：
- 将每个非 static 成员逐个拷贝到正在创建的对象中
- 对于类类型成员，使用其拷贝构造函数来拷贝
- 内置类型成员直接拷贝
- 数组逐元素地拷贝每一个成员，如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝

拷贝构造函数会在以下几种情况被隐式使用，因此不应该是 explicit 的：
- 使用 = 定义对象
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些类类型会对它们所分配的对象使用拷贝初始化

直接初始化和拷贝初始化：
- 直接初始化使用普通的函数匹配来选择参数最匹配的构造函数
- 拷贝初始化将右侧运算对象拷贝到正在创建的对象中，如果需要的话还会进行类型转换
- 在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象，但此时拷贝/移动构造函数必须存在并且可访问
```C++
string null_book = "9-999-99999-9"; //拷贝初始化
string null_book("9-999-99999-9"); //直接初始化
```

## 拷贝赋值运算符

赋值运算符通常应该返回一个指向其左侧运算对象的引用

合成的拷贝赋值运算符：
- 将右侧对象的每个非 static 成员赋予左侧运算对象的对应成员
- 通过成员的拷贝赋值运算符完成
- 返回一个指向其左侧运算对象的引用


## 析构函数

析构函数释放对象使用的资源，并销毁对象的非 static 数据成员

析构函数是类的一个成员函数，名字由 ~ 接类名构成，它没有返回值，也不接受参数
```C++
class Foo {
public:
    ~Foo(); //析构函数
};
```

由于析构函数不接受参数，因此不能被重载

析构函数的工作：
- 析构函数有一个函数体和一个析构部分
- 在一个析构函数中，首先执行函数体，然后销毁对象，成员按初始化顺序的逆序销毁
- 析构部分是隐式的，成员销毁时发生什么完全依赖于成员的类型：
    + 销毁类类型的成员需要执行成员自己的析构函数
    + 内置类型没有析构函数，因此销毁内置类型成员什么也不需要做
- 在设计时，析构函数应当释放对象在生存周期分配的所有资源

析构函数调用的时机：
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

合成的析构函数：
- 合成的析构函数的函数体为空

析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的

complex类
```C++
#ifndef __COMPLEX__
#define __COMPLEX__

class complex 
{
public:
    complex(double r = 0, double i = 0)
    : re(r), im(i)
    {   }

    double real() const { return re; }
    double imag() const { return im; }

    complex& operator += (const complex& r);
    complex& operator -= (const complex& r);
    complex& operator *= (const complex& r);
    complex& operator /= (const complex& r);

private:
    double re;
    double im;

    friend complex& __doapl(complex* ths, const complex& r);
    friend complex& __doami(complex* ths, const complex& r);
    friend complex& __doaml(complex* ths, const complex& r);
};

complex& __doapl(complex* ths, const complex& r)
{
    ths->re += r.re;
    ths->im += r.im; 
    return *ths;
}

complex& complex::operator += (const complex& r)
{
    return __doapl(this, r);
}

complex& __doami(complex* ths, const complex& r)
{
    ths->re -= r.re;
    ths->im -= r.im;
    return *ths;
}

complex& complex::operator -= (const complex& r)
{
    return  __doami(this, r);
}

complex& __doaml(complex* ths, const complex& r)
{
    double f = ths->re * r.re - ths->im * r.im;
    ths->im = ths->re * r.im + ths->im * r.re;
    ths->re = f;
    return *ths;
}

complex& complex::operator *= (const complex& r)
{
    return __doami(this, r);
}

inline double real(const complex& r)
{
    return r.real();
}

inline double imag(const complex& r)
{
    return r.imag();
}

inline complex operator + (const complex& x, const complex& y)
{
    return complex(real(x) + real(y), imag(x) + imag(y));
}

inline complex operator + (double x, const complex& y)
{
    return complex(x + real(y), imag(y));
}

inline complex operator + (const complex& x, double y)
{
    return complex(real(x) + y, imag(x));
}

inline complex operator - (const complex& x, const complex& y)
{
    return complex(real(x) - real(y), imag(x) - imag(y));
}

inline complex operator - (const complex& x, double y)
{
    return complex(real(x) - y, imag(x));
}

inline complex operator - (double x, const complex& y)
{
    return complex(x - real(y), imag(y));
}

inline complex operator * (const complex& x, const complex& y)
{
    return complex(real(x) * real(y) - imag(x) * imag(y), real(x) * imag(y) + imag(x) * real(y));
}

inline complex operator * (const complex& x, double y)
{
    return complex(real(x) * y, imag(x));
}

inline complex operator * (double x, const complex& y)
{
    return complex(x * real(y), imag(y));
}

inline complex operator / (const complex& x, double y)
{
    return complex(real(x) / y, imag(x) / y);
}

inline complex operator + (const complex& r)
{
    return r;
}

inline complex operator - (const complex& r)
{
    return complex(-real(r), -imag(r));
}

inline bool operator == (const complex& x, const complex& y)
{
    return (real(x) == real(y) && imag(x) == imag(y));
}

inline bool operator == (const complex& x, double y)
{
    return (real(x) == y && imag(x) == 0);
}

inline bool operator == (double x, const complex& y)
{
    return (x == real(y) && imag(y) == 0);
}

inline bool operator != (const complex& x, const complex& y)
{
    return (real(x) != real(y) || imag(x) != imag(y));
}

inline bool operator != (const complex& x, double y)
{
    return (real(x) != y || imag(x) != 0);
}

inline bool operator != (double x, const complex& y)
{
    return (x != real(y) || imag(y) != 0);
}

#include <cmath>

inline complex polar (double r, double t)
{
  return complex (r * cos (t), r * sin (t));
}

inline complex conj (const complex& x) 
{
  return complex (real (x), -imag (x));
}

inline double norm (const complex& x)
{
  return real (x) * real (x) + imag (x) * imag (x);
}

#include <iostream>
using namespace std;

inline ostream& operator << (ostream& os, const complex& r)
{
    return os << real(r) << " + j" << imag(r); 
}

#endif
```

Big Three 三个特殊函数
- 拷贝构造函数
- 拷贝赋值函数
- 析构函数

class with pointer members 必须有 copy ctor 和 copy op=

拷贝构造函数

浅拷贝与深拷贝

拷贝赋值函数
- 检测自我赋值



string类
```

```

构造函数：
- 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行
- 构造函数的名称与类的名称相同，并且没有返回值

析构函数：
- 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行
- 析构函数的名称与类的名称相同，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数
- 析构函数有助于在跳出程序前释放资源

拷贝构造函数调用时机：
- 用已经创建好的对象初始化新的对象
- 以值传递的方式对函数参数进行传值
- 以值方式返回局部对象


Object Based（基于对象）：面对的是单一class的设计
Object Oriented（面向对象）：面对的是多重classes的设计，classes和classes之间的关系

Classes的两个经典分类：
- Class without pointer members
- Class with pointer members

头文件中的防卫式声明
```C++
#ifndef __COMPLEX__
#define __COMPLEX__

#endif
```
