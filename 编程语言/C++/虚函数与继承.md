# 继承与面向对象程序设计

## OOP 概述

面向对象程序设计的核心思想：
- 数据抽象：将类的接口和实现分离
- 继承：定义相似的类型并对其相似关系建模
- 动态绑定：在一定程度上忽略相似类型的区别，以统一的方式使用它们的对象

通过继承联系在一起的类构成一种层次关系：
- 在层次关系的根部有一个基类
- 其他类直接或间接地从基类继承而来，称为派生类
- 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员

## 基类和派生类

基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此

基类将它的两种成员函数区分开来：
- 一种是希望其派生类进行覆盖（override）的函数，通常定义为虚函数
- 一种是基类希望派生类直接继承而不要改变的函数

对于某些函数，基类希望派生类各自定义适合自己的版本，此时基类就将这些函数声明成虚函数
```C++
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```

当我们使用指针或引用调用虚函数时，该调用将被动态绑定：根据引用或指针所绑定的对象可类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本

基类通过在其成员函数的声明语句之前加上关键字 virtual 使得该函数执行动态绑定

任何构造函数之外的非静态函数都可以是虚函数

关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义

如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时

派生类必须通过使用派生类列表明确指出它是从哪个基类继承而来的
- 类派生列表的格式：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符
```C++
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
```

派生类必须将其继承来的成员函数中需要覆盖的那些重新声明

访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见
- 如果一个派生是公有的，则基类的共有成员也是派生类接口的组成部分，能将公共派生类类型的对象绑定到基类的引用或指针上

如果派生类没有覆盖其在基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本

一个派生类包含多个组成部分：
- 一个含有派生类自己定义的（非静态）成员的子对象
- 一个与该派生类继承的基类对应的子对象，如果有多个基类，这样的子对象有多个

派生类到基类的类型转换：
- 因为在派生类对象中有与其基类对应的组成部分，所以能把派生类的对象当成基类的对象来使用，而且也能将基类的指针或引用绑定到派生类对象中的基类部分上

每个类控制它自己的成员初始化过程：
- 派生类必须使用基类的构造函数来初始化它的基类部分
- 首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员

继承与静态成员：
- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义
- 静态成员遵循通用的访问控制规则
- 假设某静态成员是可访问的，我们既能通过基类使用它也能通过派生类使用它

派生类的声明：
- 派生类的声明中包含类名但是不包含它的派生列表
- 声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，派生列表以及与定义有关的其他细节必须与类的主体一起出现

如果想将某个类用作基类，该类必须已经定义而非仅仅声明：
- 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么
- 因此一个类不能派生它本身

可以将基类的指针或引用绑定到派生类对象上：
- 当使用基类的引用或指针时，实际上并不清楚该引用或指针所绑定对象的真实类型，该对象可能是基类的对象，也可能是派生类的对象

静态类型和动态类型：
- 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
- 动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致

基类的指针或引用的静态类型可能与动态类型不一致


- 之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上
- 因为一个派生类对象可能是基类的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换

即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类到派生类的转换
- 编译器在编译时无法确定某个特定的转换在运行时是否合法，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法
- 如果在基类中含有一个或多个虚函数，可以使用 dynamic_cast 请求一个类型转换，该转换的安全检查将在运行时执行
- 如果已知某个基类向派生类的转换是安全的，则可以使用 static_cast 来强制覆盖掉编译器的检查工作

派生类向基类的类型转换只对指针或引用类型有效，在派生类对象和基类对象之间不存在这样的转换

当使用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉（切掉）

## 虚函数

使用基类的引用或指针调用一个虚成员函数时会执行动态绑定
- 因为直到运行时才知道到底调用了哪个版本的虚函数：被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个
- 所以所有的虚函数都必须有定义

动态绑定只有当我们通过指针或引用调用虚函数时才会发生

当通过一个具有普通类型的表达式调用虚函数时，在编译时就会将调用的版本确定下来

在派生类中覆盖了某个函数时，可以再一次使用 virtual 关键字指出该函数的性质，但不是必须的，因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数

- 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致
- 派生类中虚函数的返回类型也必须与基类函数匹配，除非当类的虚函数返回类型是类本身的指针或引用时

虚函数可以拥有默认实参：
- 如果某次函数调用中使用了默认实参，则该实参值由本次调用的静态类型决定
- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

使用作用域运算符回避虚函数机制：
- 对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本
- 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域定义符，则在运行时该调用被解析为对派生类版本自身的调用，从而导致无限递归

## 抽象基类

纯虚函数：
- 纯虚函数无须定义，通过在函数体的位置书写 =0 将一个虚函数说明为纯虚函数
- =0 只能出现在类内部的虚函数声明语句处
- 可以为纯虚函数提供定义，不过函数体必须在类的外部

含有或未经覆盖直接继承纯虚函数的类是抽象基类
- 抽象基类负责定义接口，而后续的其他类可以覆盖该接口
- 不能直接创建一个抽象基类的对象

## 访问控制与继承

每个类分别控制着其成员对派生类来说是否可访问

一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员
- 受保护的成员对于类的用户来说是不可访问的
- 受保护的成员对于派生类的成员和友元来说是可访问的
- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权

某个类对其继承而来的成员的访问权限受到两个因素的影响：
- 一是基类中该成员的访问说明符
- 二是在派生类的派生列表中的访问说明符

派生访问说明符对与派生类的成员及友元能否访问其直接基类的成员没什么影响，派生类对基类成员的访问权限只与基类中的访问说明符有关

派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限

派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响
- 只有当 D 公有地继承 B 时，用户代码才能使用派生类到基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换
- 不论 D 以什么方式继承 B，D的成员函数和友元都能使用派生类向基类的转换
- 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换，反之不行

使用 using 声明改变派生类继承的某个名字的访问级别：
- 通过在类的内部使用 using 声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来
- using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定
- 派生类只能为那些它可以访问的名字提供 using 声明

默认的继承保护级别：
- 使用 class 关键字定义的派生类是私有继承的
- 使用 struct 关键字定义的派生类是共有继承的

struct 关键字和 class 关键字唯一的差别就是默认成员访问说明符以及默认派生访问说明符不同

## 继承中的类作用域

每个类定义自己的作用域：
- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 如果一个名字在派生类的作用域内无法正常解析，则编译器将继续在外层的基类作用域中寻找该名字的定义

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型和动态类型可能不一致，但是能使用哪些成员仍然是由静态类型决定的

派生类能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字

可以通过作用域运算符来使用一个被隐藏的基类成员

除了覆盖继承而来的虚函数外，派生类最好不要重用其他定义在基类中的名字

声明在内层作用域的函数并不会重载声明在外层作用域的函数，因此定义在派生类中的函数也不会重载其基类中的成员

名字查找与继承： 调用 p->mem()
- 首先确定 p 的静态类型
- 在 p 的静态类型对应的类中查找 mem，如果找不到，依次在直接基类中不断查找直至到达继承链的顶端
- 一旦找到了 mem，就进行常规的类型检查以确认对于当前找到的 mem，本次调用是否合法
- 如果 mem 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型
- 如果 mem 不是虚函数或者我们是通过对象进行的调用，则编译器将产生一个常规函数调用

如果基类与派生类的虚函数接受的实参不同，就无法通过基类的指针或引用调用派生类的虚函数了

成员函数无论是否是虚函数都能被重载
- 派生类可以重载函数的零个或多个实例，如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖
- 为重载成员提供一条 using 声明语句，指定一个名字而不指定形参列表可以将该函数的所有重载实例添加到派生类作用域中，这样就无须覆盖基类中的每一个重载版本了

## 构造函数和拷贝控制

### 虚析构函数

继承关系对基类拷贝控制最直接的影响是基类应该定义一个虚析构函数
- 基类通常应该定义一个虚析构函数，这样才能动态分配继承体系中的对象
- 当 delete 一个动态分配的对象的指针时将执行析构函数，如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型和动态类型不符的情况，通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本
- 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生为定义的行为

基类需要一个虚析构函数对基类和派生类的定义产生另外一个间接的影响：
- 虚析构函数将阻止合成移动操作
- 如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作

### 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的作用：
- 对类本身的成员依次进行初始化、赋值或销毁的操作
- 使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作

派生类使用基类的拷贝控制成员的唯一要求是相应的成员应该可以访问，并且不是一个被删除的函数

如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类的成员来执行派生类对象基类部分的构造、赋值或销毁操作

如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分

编译器不会合成一个删除掉的移动操作：
- 当使用 =default 请求一个移动操作时，如果基类中对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象中的基类部分不可移动
- 如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数将是被删除的

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义

### 派生类的拷贝控制成员

派生类的构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分

派生类的拷贝和移动构造函数在拷贝和移动自有成员时，也要拷贝和移动基类部分的成员，派生类赋值运算符也必须为其基类部分的成员赋值

默认情况下基类的默认构造函数初始化对象的基类部分，要想使用使用拷贝或移动构造函数，必须在构造函数初始值列表中显示地调用该构造函数

派生类析构函数：
- 在析构函数体执行完成后，对象的成员会被隐式销毁，对象的基类部分也是隐式销毁的
- 派生类析构函数只负责析构由派生类自己分配的资源
- 对象销毁的顺序正好与其创建的顺序相反：派生类析构函数先执行，然后是基类的析构函数，沿着继承体系的反方向直至最后

```C++
class Base { ... };
class D: public Base {
public:
    D(const D& d): Base(d)  // 拷贝基类成员 
    { ... }

    D(D&& d): Base(std::move(d)) //移动基类成员
    { .. }

    D &D::operator=(const D &rhs) //Base::operator=(const Base&)不会被自动调用
    {
        Base::operator=(rhs); //为基类部分赋值
        ...
    }

    ～D（） // Base::~Base被自动调用执行
    { ... }
};
```

### 在构造函数和析构函数中调用虚函数

执行下述基类成员的时，该对象处于未完成的状态：
- 派生类对象的基类部分将首先被构建，当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态
- 销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了

为了正确处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中仿佛改变了一样

当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个，对虚函数的调用的绑定正好符合这种把对象的类和构造函数的类看成同一个的要求，对析构函数也是同样的道理

当基类构造函数调用虚函数的派生类版本时，虚函数可能会访问派生类的成员，然而当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型对应的虚函数版本

### 继承的构造函数

派生类能构重用其直接基类定义的构造函数
- 一个类只能初始化它的直接基类，一个类也只能继承其直接基类的构造函数
- 类不能继承默认、拷贝和移动构造函数
- 派生类继承基类构造函数的方式是提供一条注明了直接基类名称的 using 声明语句

通常 using 声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，using 声明语句将令编译器产生代码，对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数
```C++
derived(parms) : base(args) { }
```
如果派生类含有自己的数据成员，则这些成员会被默认初始化

和不同成员的 using 声明不一样， 一个构造函数的 using 声明不会改变该构造函数的访问级别

一个 using 声明语句不能指定 explicit 或 constexpr

当一个基类构造函数含有默认实参时，这些实参并不会被继承，相反派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参

如果基类含有几个构造函数，大多数时候派生类会继承所有这些构造函数，除了两个特例：
- 派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本
- 默认、拷贝和移动构造函数不会被继承

## 多重继承与虚继承

### 多重继承

多重继承是指从多个直接基类中产生派生类的能力，多重继承的派生类继承了所有父类的属性
- 在派生类的派生列表中可以包含多个基类
- 每个基类包含一个可选的访问说明符
- 多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是 final 的
- 对于派生类能够继承的基类个数，C++ 没有进行特殊规定，但是在某个给定的派生类列表中，同一个基类只能出现一次

在多重继承关系中，派生类的对象包含有每个基类的子对象

构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值也只能初始化它的直接基类
- 派生类的构造函数初始值列表将实参分别传递给每个直接基类
- 其中基类的构造顺序与派生列表中基类出现的顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关

如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本

派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的

析构函数的调用顺序正好和构造函数相反

多重继承的派生类如果自己定义了自己的拷贝/赋值构造函数和赋值运算符，必须在完整的对象上执行拷贝、移动或赋值操作

只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作

在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作

### 类型转换与多个基类

可以令某个可访问基类的指针或引用直接指向一个派生类对象

编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好

对象、指针和引用的静态类型决定了我们能够使用哪些成员

### 多重继承下的类作用域

在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程沿着继承体系自底向上进行，直到找到所需的名字，派生类的名字将隐藏基类的同名成员

在多重继承的情况下，相同的查找过程在所有直接基类中同时进行，如果名字在多个基类中都被找到，则对该名字的使用将具有二义性

想要避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本

对于一个派生类来说，从他的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本

### 虚继承

尽管在派生类列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类
- 派生类可以通过它的两个直接基类分别继承同一个间接基类
- 也可以直接继承某个基类，然后再通过另一个基类再一次间接继承该类

虚继承机制：
- 虚继承的目的是令某个类作出声明，承诺愿意共享它的基类
- 共享的基类子对象称为虚基类
- 这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象

虚继承的一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作

虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身

指定虚基类的方式在派生类列表中添加关键字 virtual

virtual 说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一分实例

虚基类成员的可见性：
- 因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性
- 如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖成员
- 如果成员被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本

### 构造函数和虚继承

在虚派生中，虚基类是由最底层的派生类初始化的

继承体系中的每个类都可能在某个时刻成为最底层的派生类，只要我们创建基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类

虚继承的对象的构造方式：
- 首先使用提供给最底层派生类的初始值初始化该对象的虚基类部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化
- 虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关





