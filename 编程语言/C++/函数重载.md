# 函数重载

函数重载是指在同一作用域中声明几个类似的同名函数
- 函数名称必须相同
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）
- 函数的返回类型可以相同也可以不相同

<font color="#dd0000">仅仅返回类型不同不足以成为函数的重载的条件</font><br />

## 运算符重载基本概念

当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义
- 重载的运算符是具有特殊名字的函数：他们的名字右关键字 operator 和其后要定义的运算符号共同组成
- 和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体
- 重载运算符的参数数量与该运算符作用的运算对象数量一样多
- 除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参
- 对于一个重载的运算符是成员函数时，this 绑定到左侧运算对象，成员运算符函数的显式参数数量比运算对象的数量少一个
- 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数
- 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致

不能被重载的运算符： ::  .*  .   ?: 

调用重载的运算符函数：
- 将运算符作用于类型正确的实参，从而以这种间接方式调用重载的运算符函数
- 像普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参
```C++
data1 + data2;
operator+(data1, data2);
```

不建议重载的运算符：
- 逻辑与运算符、逻辑或运算符和逗号运算符：他们的运算对象求值顺序的规则无法应用到重载的运算符上
- && 和 || 运算符的重载版本无法保留内置运算符的短路求值属性
- 取地址运算符

使用与内置类型一致的含义：只有当操作的含义对于用户来说清晰明了时才用运算符
- 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
- 如果类的某个操作是检查相等性，则定义 operator==，如果类有 operaotr== 也应该有 operator！=
- 如果类包含一个内在的单序比较操作，则定义 operator<，如果类有 operaotr< 也应该有其他关系操作
  
重载运算符的返回类型应该与内置版本的返回类型兼容：
- 逻辑运算符和关系运算符应该返回 bool
- 算术运算符应该返回一个类类型的值
- 赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用
- 如果类含有算术运算符或位运算符，最好也提供对应的复合赋值运算符

选择作为成员还是非成员：
- 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等等，因此它们通常应该是普通的非成员函数

如果想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数

## 输入输出运算符

### 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用
- ostream 是非常量是因为向流写入内容会改变其状态
- 该形参是引用是因为我们无法直接复制一个 ostream 对象

第二个形参一般来说是一个常量的引用
- 是引用的原因是我们希望避免复制实参
- 是常量是因为打印对象不会改变对象的内容

为了与其他输出运算符保持一致， operator<< 一般要返回它的 ostream 形参

输出运算符应该主要打印对象的内容而非控制格式，输出运算符不应该打印换行符

与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数

IO 运算符通常需要读写类的非共有数据成员，所以 IO 运算符一般被声明为友元

### 重载输入运算符

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读到的非常量对象的引用，该运算符通常会返回某个给定流的引用

第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中

输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 当流含有错误类型的数据时读取操作可能失败
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败
- 当读取操作发生错误时，输入运算符应该负责从错误中恢复

## 算术和关系运算符

通常情况下，把算术运算符和关系运算符定义为非成员函数以允许对左侧或右侧的运算对象进行转换

这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用

一般如果类定义了算术运算符，一般也会定义一个对应的复合赋值运算符，最有效方式的是使用复合赋值来定义算术运算符

### 相等运算符

在通常情况下，C++ 中的类通过定义相等运算符来检验两个对象是否相等
- 如果一个类含有判断两个对象是否相等的操作，则应该把函数定义成 operaotr== 而非一个普通命名函数
- 如果类定义了 operator==，则应该能判断一组给定数据中是否含有重复数据
- 相等运算应该具有传递性
- 如果类定义了 operator==，则这个类也应该定义 operator!=
- 相等运算符和不相等运算符中的一个应该把工作委托给另外一个

### 关系运算符

定义了相等运算符的类也常常包含关系运算符
- 关系运算符应该定义顺序关系，令其与关联容器中对关键字的要求一致
- 如果类同时含有 == 运算符的话，则定义一种关系与 == 保持一致

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符，如果类同时还包含 ==，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符

## 赋值运算符

不论形参的类型是什么，赋值运算符都必须定义为成员函数

复合赋值运算符不非得是类的成员，不过还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部

为了与内置类型的赋值运算符保持一致，赋值运算符应该返回左侧运算对象的引用


## 下标运算符

下标运算符必须是成员函数

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用

## 递增和递减运算符

C++ 语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作的对象的状态，所以建议将其设定为成员函数

定义递增和递减运算符的类应该同时定义前置和后置版本

为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用，后置运算符应该返回对象的原值

普通的函数重载无法区分前置和后置运算符，因此后置运算符接受一个额外的不被使用的 int 类型的形参
- 因为不会用到 int 形参，所以无须为其命名
- 编译器为这个形参提供一个值为 0 的实参
- 如果向通过函数调用的方式调用后置版本，必须为它的整形参数传递一个值

## 成员访问运算符

箭头运算符必须是类的成员，解引用运算符通常也是类的成员

重载箭头运算符时，可以改变的是箭头从哪个对象中获取成员，而箭头获取成员这一事实则永远不变

重载的箭头运算符必须返回类的指针或者自定义了箭头指针的某个类的对象

point->mem 的执行过程：
- 如果 point 是指针，则应用内置的箭头运算符，表达式等价于 (*point).mem：首先解引用该指针，然后从所得的对象中获取指定的成员
- 如果 point 是定义了 operator-> 的类的一个对象，则使用 point.operator->() 的结果来获取 mem。如果该结果是一个指针，则执行第一点的步骤，如果该结果本身含有重载的 operator->()，则重复调用当前步骤


## 函数调用运算符

函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别

如果该类定义了调用运算符，则该类被称作函数对象

函数对象类通常含有一些数据成员用于定制调用运算符中的操作

函数对象通常作为泛型算法的实参

### lambda 是函数对象

当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符

表示 lambda 及相应捕获行为的类：
- 当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时引用所引的对象确实存在，因此编译器可以直接使用该引用而无需在 lambda 产生的类中将其存储为数据成员
- 通过值捕获的变量被拷贝到 lambda 中，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员

lambda 表达式产生的类不包含默认构造函数、赋值运算符及默认析构函数，它是否有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定

### 标准库定义的函数对象

标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符

这些类都被定义成模板的形式，可以为其指定具体的应用类型，这里的类型指调用运算符的形参类型

|       算数        |        关系         |        逻辑        |
|       :-:        |         :-:         |         :-:        |
| plus<Type>       | equal_to<Type>      |  logical_and<Type> | 
| minus<Type>      | not_equal_to<Type>  |  logical_or<Type>  | 
| multiplies<Type> | greater<Type>       |  logical_not<Type> | 
| divides<Type>    | greater_equal<Type> |                    | 
| modulus<Type>    | less<Type>          |                    | 
| negate<Type>     | less_equal<Type>    |                    | 




表示运算符的函数


## 重载、类型转换与运算符








