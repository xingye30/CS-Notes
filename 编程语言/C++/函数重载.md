# 函数重载

函数重载是指在同一作用域中声明几个类似的同名函数
- 函数名称必须相同
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）
- 函数的返回类型可以相同也可以不相同

<font color="#dd0000">仅仅返回类型不同不足以成为函数的重载的条件</font><br />

## 运算符重载基本概念

当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义
- 重载的运算符是具有特殊名字的函数：他们的名字右关键字 operator 和其后要定义的运算符号共同组成
- 和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体
- 重载运算符的参数数量与该运算符作用的运算对象数量一样多
- 除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参
- 对于一个重载的运算符是成员函数时，this 绑定到左侧运算对象，成员运算符函数的显式参数数量比运算对象的数量少一个
- 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数
- 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致

不能被重载的运算符： ::  .*  .   ?: 

调用重载的运算符函数：
- 将运算符作用于类型正确的实参，从而以这种间接方式调用重载的运算符函数
- 像普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参
```C++
data1 + data2;
operator+(data1, data2);
```

不建议重载的运算符：
- 逻辑与运算符、逻辑或运算符和逗号运算符：他们的运算对象求值顺序的规则无法应用到重载的运算符上
- && 和 || 运算符的重载版本无法保留内置运算符的短路求值属性
- 取地址运算符

使用与内置类型一致的含义：只有当操作的含义对于用户来说清晰明了时才用运算符
- 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
- 如果类的某个操作是检查相等性，则定义 operator==，如果类有 operaotr== 也应该有 operator！=
- 如果类包含一个内在的单序比较操作，则定义 operator<，如果类有 operaotr< 也应该有其他关系操作
  
重载运算符的返回类型应该与内置版本的返回类型兼容：
- 逻辑运算符和关系运算符应该返回 bool
- 算术运算符应该返回一个类类型的值
- 赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用
- 如果类含有算术运算符或位运算符，最好也提供对应的复合赋值运算符

选择作为成员还是非成员：
- 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等等，因此它们通常应该是普通的非成员函数

如果想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数

## 输入输出运算符

### 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用
- ostream 是非常量是因为向流写入内容会改变其状态
- 该形参是引用是因为我们无法直接复制一个 ostream 对象

第二个形参一般来说是一个常量的引用
- 是引用的原因是我们希望避免复制实参
- 是常量是因为打印对象不会改变对象的内容

为了与其他输出运算符保持一致， operator<< 一般要返回它的 ostream 形参

输出运算符应该主要打印对象的内容而非控制格式，输出运算符不应该打印换行符

与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数

IO 运算符通常需要读写类的非共有数据成员，所以 IO 运算符一般被声明为友元

### 重载输入运算符

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读到的非常量对象的引用，该运算符通常会返回某个给定流的引用

第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中

输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 当流含有错误类型的数据时读取操作可能失败
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败
- 当读取操作发生错误时，输入运算符应该负责从错误中恢复

## 算术和关系运算符

通常情况下，把算术运算符和关系运算符定义为非成员函数以允许对左侧或右侧的运算对象进行转换

这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用

一般如果类定义了算术运算符，一般也会定义一个对应的复合赋值运算符，最有效方式的是使用复合赋值来定义算术运算符

### 相等运算符

在通常情况下，C++ 中的类通过定义相等运算符来检验两个对象是否相等
- 如果一个类含有判断两个对象是否相等的操作，则应该把函数定义成 operaotr== 而非一个普通命名函数
- 如果类定义了 operator==，则应该能判断一组给定数据中是否含有重复数据
- 相等运算应该具有传递性
- 如果类定义了 operator==，则这个类也应该定义 operator!=
- 相等运算符和不相等运算符中的一个应该把工作委托给另外一个

### 关系运算符

定义了相等运算符的类也常常包含关系运算符
- 关系运算符应该定义顺序关系，令其与关联容器中对关键字的要求一致
- 如果类同时含有 == 运算符的话，则定义一种关系与 == 保持一致

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符，如果类同时还包含 ==，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符

## 赋值运算符

不论形参的类型是什么，赋值运算符都必须定义为成员函数

复合赋值运算符不非得是类的成员，不过还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部

为了与内置类型的赋值运算符保持一致，赋值运算符应该返回左侧运算对象的引用


## 下标运算符

下标运算符必须是成员函数

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用

## 递增和递减运算符

## 成员访问运算符

## 函数调用运算符

## 重载、类型转换与运算符








