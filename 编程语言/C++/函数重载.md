# 函数重载

函数重载是指在同一作用域中声明几个类似的同名函数
- 函数名称必须相同
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）
- 函数的返回类型可以相同也可以不相同

<font color="#dd0000">仅仅返回类型不同不足以成为函数的重载的条件</font><br />

## 运算符重载基本概念

当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义
- 重载的运算符是具有特殊名字的函数：他们的名字右关键字 operator 和其后要定义的运算符号共同组成
- 和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体
- 重载运算符的参数数量与该运算符作用的运算对象数量一样多
- 除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参
- 对于一个重载的运算符是成员函数时，this 绑定到左侧运算对象，成员运算符函数的显式参数数量比运算对象的数量少一个
- 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数
- 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致

不能被重载的运算符： ::  .*  .   ?: 

调用重载的运算符函数：
- 将运算符作用于类型正确的实参，从而以这种间接方式调用重载的运算符函数
- 像普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参
```C++
data1 + data2;
operator+(data1, data2);
```

不建议重载的运算符：
- 逻辑与运算符、逻辑或运算符和逗号运算符：他们的运算对象求值顺序的规则无法应用到重载的运算符上
- && 和 || 运算符的重载版本无法保留内置运算符的短路求值属性
- 取地址运算符

使用与内置类型一致的含义：只有当操作的含义对于用户来说清晰明了时才用运算符
- 如果类执行 IO 操作，则定义移位运算符使其与内置类型的 IO 保持一致
- 如果类的某个操作是检查相等性，则定义 operator==，如果类有 operaotr== 也应该有 operator！=
- 如果类包含一个内在的单序比较操作，则定义 operator<，如果类有 operaotr< 也应该有其他关系操作
  
重载运算符的返回类型应该与内置版本的返回类型兼容：
- 逻辑运算符和关系运算符应该返回 bool
- 算术运算符应该返回一个类类型的值
- 赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用
- 如果类含有算术运算符或位运算符，最好也提供对应的复合赋值运算符

选择作为成员还是非成员：
- 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须是成员
- 复合赋值运算符一般来说应该是成员，但并非必须
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算等等，因此它们通常应该是普通的非成员函数

如果想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数

## 输入输出运算符

### 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用
- ostream 是非常量是因为向流写入内容会改变其状态
- 该形参是引用是因为我们无法直接复制一个 ostream 对象

第二个形参一般来说是一个常量的引用
- 是引用的原因是我们希望避免复制实参
- 是常量是因为打印对象不会改变对象的内容

为了与其他输出运算符保持一致， operator<< 一般要返回它的 ostream 形参

输出运算符应该主要打印对象的内容而非控制格式，输出运算符不应该打印换行符

与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数

IO 运算符通常需要读写类的非共有数据成员，所以 IO 运算符一般被声明为友元

### 重载输入运算符

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读到的非常量对象的引用，该运算符通常会返回某个给定流的引用

第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中

输入运算符必须处理输入可能失败的情况，而输出运算符不需要
- 当流含有错误类型的数据时读取操作可能失败
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败
- 当读取操作发生错误时，输入运算符应该负责从错误中恢复

## 算术和关系运算符

通常情况下，把算术运算符和关系运算符定义为非成员函数以允许对左侧或右侧的运算对象进行转换

这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用

一般如果类定义了算术运算符，一般也会定义一个对应的复合赋值运算符，最有效方式的是使用复合赋值来定义算术运算符

### 相等运算符

在通常情况下，C++ 中的类通过定义相等运算符来检验两个对象是否相等
- 如果一个类含有判断两个对象是否相等的操作，则应该把函数定义成 operaotr== 而非一个普通命名函数
- 如果类定义了 operator==，则应该能判断一组给定数据中是否含有重复数据
- 相等运算应该具有传递性
- 如果类定义了 operator==，则这个类也应该定义 operator!=
- 相等运算符和不相等运算符中的一个应该把工作委托给另外一个

### 关系运算符

定义了相等运算符的类也常常包含关系运算符
- 关系运算符应该定义顺序关系，令其与关联容器中对关键字的要求一致
- 如果类同时含有 == 运算符的话，则定义一种关系与 == 保持一致

如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符，如果类同时还包含 ==，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符

## 赋值运算符

不论形参的类型是什么，赋值运算符都必须定义为成员函数

复合赋值运算符不非得是类的成员，不过还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部

为了与内置类型的赋值运算符保持一致，赋值运算符应该返回左侧运算对象的引用


## 下标运算符

下标运算符必须是成员函数

如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用

## 递增和递减运算符

C++ 语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作的对象的状态，所以建议将其设定为成员函数

定义递增和递减运算符的类应该同时定义前置和后置版本

为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用，后置运算符应该返回对象的原值

普通的函数重载无法区分前置和后置运算符，因此后置运算符接受一个额外的不被使用的 int 类型的形参
- 因为不会用到 int 形参，所以无须为其命名
- 编译器为这个形参提供一个值为 0 的实参
- 如果向通过函数调用的方式调用后置版本，必须为它的整形参数传递一个值

## 成员访问运算符

箭头运算符必须是类的成员，解引用运算符通常也是类的成员

重载箭头运算符时，可以改变的是箭头从哪个对象中获取成员，而箭头获取成员这一事实则永远不变

重载的箭头运算符必须返回类的指针或者自定义了箭头指针的某个类的对象

point->mem 的执行过程：
- 如果 point 是指针，则应用内置的箭头运算符，表达式等价于 (*point).mem：首先解引用该指针，然后从所得的对象中获取指定的成员
- 如果 point 是定义了 operator-> 的类的一个对象，则使用 point.operator->() 的结果来获取 mem。如果该结果是一个指针，则执行第一点的步骤，如果该结果本身含有重载的 operator->()，则重复调用当前步骤


## 函数调用运算符

函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别

如果该类定义了调用运算符，则该类被称作函数对象

函数对象类通常含有一些数据成员用于定制调用运算符中的操作

函数对象通常作为泛型算法的实参

### lambda 是函数对象

当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 lambda 表达式产生的类中含有一个重载的函数调用运算符

表示 lambda 及相应捕获行为的类：
- 当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时引用所引的对象确实存在，因此编译器可以直接使用该引用而无需在 lambda 产生的类中将其存储为数据成员
- 通过值捕获的变量被拷贝到 lambda 中，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员

lambda 表达式产生的类不包含默认构造函数、赋值运算符及默认析构函数，它是否有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定

### 标准库定义的函数对象

标准库定义了一组表示算数运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符

这些类都被定义成模板的形式，可以为其指定具体的应用类型，这里的类型指调用运算符的形参类型

|       算数        |        关系         |        逻辑        |
|       :-:        |         :-:         |         :-:        |
| plus<Type>       | equal_to<Type>      |  logical_and<Type> | 
| minus<Type>      | not_equal_to<Type>  |  logical_or<Type>  | 
| multiplies<Type> | greater<Type>       |  logical_not<Type> | 
| divides<Type>    | greater_equal<Type> |                    | 
| modulus<Type>    | less<Type>          |                    | 
| negate<Type>     | less_equal<Type>    |                    | 

表示运算符的函数对象通常用来替换算法中的默认运算符

标准库规定其函数对象对于指针同样适用

### 可调用对象与 function

C++ 中有几种可调用对象：
- 函数
- 函数指针
- lambda 表达式
- bind 创建的对象
- 重载了函数调用运算符的类

可调用对象也有类型：
- 每个 lambda 有它自己唯一的未命名类类型
- 函数及函数指针的类型则由其返回值类型和实参类型决定

不同的类型的可调用对象可以具有相同的调用形式，调用形式指明了调用返回的类型以及传递给调用的实参类型

标准库 function 类型：
- function 是一个模板，他的模板参数是该 function 类型能够表示的对象的调用形式
- function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象
```C++
function<int (int, int)>
```

不能直接将重载函数的名字存入 function 类型的对象中，会产生二义性
- 解决二义性的一条途径是存储函数指针而非函数的名字
- 也能用 lambda 来消除二义性
```C++
int add(int i, int j) { return i + j; }
Sales_data add(const Sales_data&, const Sales_data&);
map<string, function<int(int, int)>> binops;
binops.insert({"+", "add"}); //错误：二义性

int (*p)(int, int) = add; //指针所指的 add 是接受两个 int 的版本
binops.insert({"+", fp}); //正确

binops.insert({"+", [](int a, int b) { return add(a, b); }}); //正确：使用 lambda 来指定我们希望使用的版本
```

## 重载、类型转换与运算符

转换构造函数和类型转换运算符共同定义了类类型转换，这样的转换有时也被称为用户定义的类型转换

### 类型转换运算符

类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型
- 类型转换运算符可以面向除了 void 之外的任意类型进行定义，只要该类型能作为函数的返回类型
  - 因此不允许转换成数组或者函数类型，但允许转换成指针或者引用类型
- 类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数
- 类型转换运算符通常不应该改变待转换对象的内容，因此类型转换运算符一般被定义成 const 成员
```C++
class SmallInt {
public:
  SmallInt(int i = 0): val(i)
  {
    if (i < 0 || i > 255)
      throw std::out_of_range("Bad SmallInt value");
  }
  operator int() const { return val; }
private:
  std::size_t val;
};

SmallInt si = 3.14; //正确，内置类型转换将 double 实参转换成 int，再调用 SmallInt(int) 构造函数
si + 3.14; //正确，SmallInt 的类型转换运算符将 si 转换成 int，内置类型转换将所得的 int 继续转换成 double
```

尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准内置类型转换之前或之后，并与其一起使用

因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参

尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值

显示的类型转换运算符：
- 编译器通常不会将一个显示的类型转换运算符用于隐身类型转换
- 当类型转换运算符是显示的时，执行类型转换必须通过显示的强制类型转换才可以

如果表达式被用作条件，则编译器会讲显示的类型转换自动应用于它：
- if、while 及 do 语句的条件部分
- for 语句头的条件表达式
- 逻辑非运算符、逻辑或运算符、逻辑与运算符的运算对象
- 条件运算符（?:）的条件表达式

对于类来说，定义向 bool 的类型转换是比较普遍的现象：
- 无论什么时候在条件中使用流对象，都会使用为 IO 类型定义的 operator bool
- 向 bool 的类型转换通常在条件部分，因此 operator bool 一般定义成 explicit 的
```C++
while (std::cin >> value) 
//如果 cin 的条件状态是 good，则 operator bool 返回真，否则返回假
```

### 避免有二义性的类型转换

如果一个类中包含一个或多个类型转换，则必须保证在类类型和目标类型之间只存在唯一一种转换方式，否则的话，我们编写的代码很可能具有二义性

在两种情况下可能产生多重转换路径：
- 两个类提供了相同的类型转换
- 类定义了多个转换规则，这些转换涉及的类型本身可以通过其他类型转换联系在一起

出现二义性时，需要显示调用类型转换运算符或者转换构造函数

无法使用强制类型转换来解决二义性，因为强制类型转换本身也面临二义性

当我们使用用户定义的类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程

规则：
- 不要令两个类执行相同的类型转换
- 避免转换目标是内置算术类型的类型转换，特别是当你已经定义了一个转换成算数类型的类型转换时
  - 不要再定义接收算术类型的重载运算符，如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符
  - 不要定义转换到多种算术类型的类型转换，让标准类型转换完成向其他算术类型转换的工作
- 除了显示地向 bool 类型的转换之外，应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显示构造函数

当调用重载函数时，如果有两个或多个用户定义的类型转换都提供了可行的匹配，则我们认为这些类型转换一样好，在这个过程中，不会考虑任何可能出现的标准类型转换的级别，只有当重载函数能通过同一个类型转换函数得到匹配时，才会考虑其中出现的标准类型转换

调用者可以显示地构造正确的类型消除二义性

### 函数匹配与重载运算符

当使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本，如果作则运算对象是类类型，则定义在该类中的运算符重载版本也包含在候选函数内

当调用一个命名函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的，当我们通过类类型的对象进行函数调用时，只考虑该类的成员函数，而当我们在表达式中使用重载运算符时，无法判断正在使用的是成员函数还是非成员函数，因此两者都应该在考虑的范围内

如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题
