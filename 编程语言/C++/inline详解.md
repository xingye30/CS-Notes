# inline 详解

inline 只适合函数体内代码简单的函数使用

inline 函数仅仅是一个对编译器的建议

内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，这要求每个调用了内联函数的文件都出现了该内联函数的定义，所以<font color="#dd0000">最好将内联函数定义放在头文件中</font><br />

<font color="#dd0000">定义在类中的成员函数默认都是内联的</font><br />, 如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline 

<font color="#dd0000">关键字 inline 必须与函数定义体放在一起才能使函数成为内联</font><br />，仅将 inline 放在函数声明前面不起任何作用

内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率
+ 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高
+ 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大
+ 类的构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数，所以不要随便地将构造函数和析构函数的定义体放在类声明中

编译器对 inline 函数的处理步骤
- 将 inline 复制到 inline 函数调用点处
- 为所用 inline 函数中的局部变量分配内存空间
- 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中
- 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）

<font color="#dd0000">虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联</font><br />
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联
- inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生