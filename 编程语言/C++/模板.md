# 模板

class template 类模板
```
template<typename T>
class complex
{
public:
  complex (T r = 0, T i = 0)
    : re (r), im (i)
  { }
  ...
private:
  T re, im;
  ...
}

complex<double> c1(2.5, 1.5);
complex<int> c2(2, 6);
```

function template 函数模板
```
template<class T>
inline 
const T& min(const T& a, const T& b)
{
  return b < a ? b : a;
}
//编译器会对function template进行参数推导
//参数推导的结果：如果T为stone，就调用stone::opeator<
```

member template 成员模板
```
template<class T1, class T2>
struct pair {
...
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) :
    first(a), second(b) {}
  
  //让构造函数更有弹性
  template<class U1, class U2>
  pair(const pair<U1, U2>& n) :
    first(p.first), second(p.second) {}
};
```

specialization 模板特化
```
//泛化
template<class Key>
struct hash { }; 

//特化
template<>
struct hash<char> {
  size_t operator()(char x) const { return x; }
};

template<>
struct hash<int> {
  size_t operator()(int x) const { return x; }
};

template<>
struct hash<long> {
  size_t operator()(long x) const { return x; }
};

cout << hash<long>()(1000);
```

partial specialization 模板偏特化

个数的偏
```
template<typename T, typename Alloc=...>
class vector
{
...
};

template<typename Alloc=...>
class vector<bool, Alloc>  //绑定  从左到右
{
...
};
```

范围的偏
```
template<typename T>
class C
{
...
};

template<typename T>
class C<T*>
{
...
};

C<string> obj1;
C<string*> obj2;
```

template template parameter 模板模板参数
```
template<typename T,
         template<typename T>
           class Container
        >
class XCls
{
private:
  Container<T> c;
public:
  ...
};

template<typename T>
using Lst = list<T, allocator<T>>;

XCls<string, list> mylst1; //错
XCls<string, Lst> mylst2; //对
```

variadic templates 可变模板参数
```
void print()
{
}

template<typename T, typename... Types>
void print(const T& firstArg, const Types&... args)
{
  cout << firstArg << endl;
  print(args...);
}
//...就是一个所谓的pack（包）
//用于template parameters，就是template parameters pack（模板参数包）
//用于function parameter types，就是function parameter types pack（函数参数类型包） 
//用于function parameter，就是function parameter pack（函数参数包） 
```