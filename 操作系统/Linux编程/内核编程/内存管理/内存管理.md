# 内存管理

## 内存寻址

### 8位寻址

8080

访问内存通过绝对地址，程序中的地址必须进行硬编码。需要给出物理地址，难以重定位。

### 16位寻址

8086 引入了段的概念

寻址空间达到1M，地址总线为20位，数据总线为16位。

将1M大的空间分成若干个64K的段来管理。

将16位的段地址左移4位，然后与16位的偏移量相加，获得一个20位的内存地址。

段描述了一块有限的内存区域，区域的起始位置存放在专门的寄存器中，也就是段寄存器中。

从16位内存地址到20位实际地址的转换，或者叫映射。这种模式叫实模式。

### 24位寻址

80286 保护模式的引入

访问内存时不能直接从段寄存器中获得段的起始地址而需要经过额外的转换和检查。

### 32位，64位寻址

i386 32位的CPU，其寻址能力达到4GB

在保护模式下，它的段范围不再受限于64K，可达到4GB

保护模式下的页表寄存器：CR0-CR3

CR0：0位是保护允许位PE，第31位是分页允许位


## 段机制

程序的编译、链接和装载：
- 编译：gcc -S hello.c -o hello.s 通过编译器编译成汇编程序
- 汇编：gcc -c hello.s -o hello.o 经过汇编器汇编成目标代码
- 链接：gcc hello.o -o a.out 经过链接器链接形成可执行文件
- 装载并执行：./a.out 通过装载器装入到内存
- 反汇编：objdump -d a.out


- 链接以后形成的地址空间是虚地址还是实地址？虚地址
- 装入程序把可执行代码装入到虚拟内存还是物理内存？
- CPU访问的是虚地址还是物理地址？ 虚地址


CPU把虚地址送给MMU，MMU把虚地址转换成物理地址送给存储器。

MMU的地址转换：虚拟地址通过分段机制转换为线性地址，再通过分页机制转换成物理地址。

段描述符表-段表
- 段号描述的是虚拟地址空间段的编号
- 基地址是线性地址空间段的起始地址
- 段描述符表中的每一个表项叫做段描述符

保护模式下段寄存器存放什么？
- 存放索引或叫段号
- 这里的段寄存器也叫选择符，即从描述符表中选择某个段
- RPL表示请求者的特权级
- TI表示段表是在全局描述符表还是在局部描述符表

保护模式下的特权级：ring0-ring3

linux系统使用ring0和ring3两个特权级

保护模式下的其他描述符表：
- 全局描述符表GDT
- 中断描述符表IDT
- 局部描述符表LDT

线性地址 = 段的起始地址 + 偏移量

Linux将段的起始地址赋为0，让线性地址等于偏移量，巧妙地绕过了段机制

## 分页

所谓分页就是将虚拟地址空间或线性地址空间划分成若干大小相等的片，称为页。

对物理地址空间分成与页大小相等的存储块，称为块或页面。

页表是一种映射机制，存放的是虚拟地址空间与物理地址空间的映射关系。

转换旁路缓冲器：TLB
- 当CPU访问地址空间中的某个地址的时候，先检查对应的页表项是不是在高速缓存TLB中，如果在就可以直接返回

